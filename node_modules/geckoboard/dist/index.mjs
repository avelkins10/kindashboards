var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// package.json
var version = "2.0.2";

// src/index.ts
import { fetch } from "undici";
var USER_AGENT = `Geckoboard Node Client ${version}`;
var Dataset = class {
  constructor(schema, gb) {
    this.id = schema.id;
    this.fields = schema.fields;
    this.uniqueBy = schema.uniqueBy;
    this.gb = gb;
  }
  create() {
    return __async(this, null, function* () {
      const { id, fields, uniqueBy } = this;
      yield this.gb.request("PUT", `/datasets/${id}`, {
        fields,
        unique_by: uniqueBy
      });
    });
  }
  replaceDateObjects(items) {
    const dateFields = [];
    const dateTimeFields = [];
    const keys = Object.keys(this.fields);
    keys.forEach((fieldName) => {
      const field = this.fields[fieldName];
      if (field.type === "date") {
        dateFields.push(fieldName);
      }
      if (field.type === "datetime") {
        dateTimeFields.push(fieldName);
      }
    });
    return items.map((item) => {
      dateFields.forEach((fieldName) => {
        const fieldValue = item[fieldName];
        if (fieldValue instanceof Date) {
          item = __spreadProps(__spreadValues({}, item), {
            [fieldName]: fieldValue.toISOString().split("T")[0]
          });
        }
      });
      dateTimeFields.forEach((fieldName) => {
        const fieldValue = item[fieldName];
        if (fieldValue instanceof Date) {
          item = __spreadProps(__spreadValues({}, item), {
            [fieldName]: fieldValue.toISOString()
          });
        }
      });
      return item;
    });
  }
  append(items, deleteBy) {
    return __async(this, null, function* () {
      const { id } = this;
      const data = this.replaceDateObjects(items);
      yield this.gb.request("POST", `/datasets/${id}/data`, {
        data,
        deleteBy
      });
    });
  }
  replace(items) {
    return __async(this, null, function* () {
      const { id } = this;
      const data = this.replaceDateObjects(items);
      yield this.gb.request("PUT", `/datasets/${id}/data`, {
        data
      });
    });
  }
  delete() {
    return __async(this, null, function* () {
      const { id } = this;
      yield this.gb.request("DELETE", `/datasets/${id}`);
    });
  }
};
var Geckoboard = class {
  constructor(apiKey) {
    this.apiKey = apiKey;
    this.apiHost = process.env.GECKOBOARD_API_HOST || "https://api.geckoboard.com";
    this.version = version;
  }
  request(method, path, body) {
    return __async(this, null, function* () {
      var _a;
      const auth = btoa(`${this.apiKey}:`);
      const headers = new Headers({
        Authorization: `Basic ${auth}`,
        "User-Agent": USER_AGENT
      });
      if (method === "POST" || method === "PUT") {
        headers.set("Content-Type", "application/json");
      }
      const res = yield fetch(new URL(path, this.apiHost), {
        body: JSON.stringify(body),
        method,
        headers
      });
      if (!res.ok) {
        const json = yield res.json();
        const message = ((_a = json.error) == null ? void 0 : _a.message) || "Something went wrong with the request";
        throw new Error(message);
      }
      return res;
    });
  }
  defineDataset(schema) {
    return new Dataset(schema, this);
  }
  ping() {
    return __async(this, null, function* () {
      yield this.request("GET", "/");
    });
  }
};
export {
  Geckoboard
};
//# sourceMappingURL=index.mjs.map